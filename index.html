<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Priority Survey: Present vs Future</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .loading-indicator {
            text-align: center;
            color: white;
            font-size: 1.2em;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-wrapper {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
            position: relative;
        }
        
        .chart-wrapper::before {
            content: '‚ö†Ô∏è ONE CLICK ONLY';
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff6b6b;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: bold;
            z-index: 10;
        }
        
        .chart-wrapper:hover {
            transform: translateY(-5px);
        }
        
        .chart-title {
            text-align: center;
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .chart-container {
            position: relative;
            width: 100%;
            height: 600px;
        }
        
        .ternary-plot {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .ternary-plot.locked {
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .instructions {
            background: rgba(255,255,255,0.95);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .instructions h2 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .instructions p {
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        .stats {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            text-align: center;
        }
        
        .stats h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .stat-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }
        
        .axis-label {
            font-weight: bold;
            font-size: 14px;
            fill: #333;
            paint-order: stroke;
            stroke: white;
            stroke-width: 3px;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .grid-line {
            stroke: #ddd;
            stroke-width: 1;
        }
        
        .point {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .point:hover {
            r: 8;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #764ba2;
            transform: scale(1.05);
        }
        
        .controls {
            text-align: center;
            margin-top: 20px;
        }

        .connection-status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .connected {
            background: #4caf50;
            color: white;
        }

        .disconnected {
            background: #f44336;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Global Priorities Survey</h1>
            <p class="subtitle">How do your priorities shift from present to future?</p>
            <div id="connectionStatus" class="connection-status disconnected">Connecting to database...</div>
        </header>
        
        <div id="loadingIndicator" class="loading-indicator" style="display: none;">
            üìä Loading existing responses...
        </div>

        <div class="instructions">
            <h2>üìä How to Use</h2>
            <p><strong>‚ö†Ô∏è IMPORTANT: You can only click ONCE per chart!</strong> Think carefully before placing your point.</p>
            <p><strong>Click anywhere</strong> inside each triangle to record your priority allocation. Your click represents how you would distribute focus across three critical global challenges.</p>
            <p>The closer your click is to a corner, the more priority you're giving to that challenge. Points near the center represent balanced priorities.</p>
            <p><strong>Challenge yourself:</strong> How do your priorities differ between today and 50 years from now?</p>
        </div>
        
        <div class="charts-container">
            <div class="chart-wrapper">
                <div class="chart-title">Present Day - 2025</div>
                <div class="chart-container">
                    <svg class="ternary-plot" id="plot2025"></svg>
                </div>
            </div>
            
            <div class="chart-wrapper">
                <div class="chart-title">Future - 2075</div>
                <div class="chart-container">
                    <svg class="ternary-plot" id="plot2075"></svg>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <h3>Response Statistics</h3>
            <div class="stat-grid">
                <div class="stat-item">
                    <div class="stat-label">2025 Responses</div>
                    <div class="stat-value" id="count2025">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">2075 Responses</div>
                    <div class="stat-value" id="count2075">0</div>
                </div>
            </div>
            <div class="controls">
                <button onclick="exportData('json')">Export as JSON</button>
                <button onclick="exportData('csv')">Export as CSV</button>
            </div>
        </div>
    </div>

    <script>
        // ===== SUPABASE CONNECTION =====
        const SUPABASE_URL = "https://moonehjcqazohpajuaho.supabase.co";
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1vb25laGpjcWF6b2hwYWp1YWhvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIxMTE5NzYsImV4cCI6MjA3NzY4Nzk3Nn0.W4eVLfOALpHBg2N7Fisv4gx6BFQXzPHhY0";
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Data storage
        let data2025 = [];
        let data2075 = [];
        
        // Track if user has responded
        let hasResponded2025 = false;
        let hasResponded2075 = false;
        
        // Generate unique user ID (nickname) for this session
        let userNickname = generateNickname();
        let isConnected = false;

        // Chart configuration
        const config = {
            width: 500,
            height: 500,
            margin: 100,
            labels: {
                A: 'Maximising AI Usage',
                B: 'Global Human Equality',
                C: 'Overcoming Climate Change'
            }
        };
        
        // Function to generate random nickname
        function generateNickname() {
            const adjectives = ['Swift', 'Bright', 'Bold', 'Wise', 'Cool', 'Quick', 'Smart', 'Clever', 'Sharp', 'Keen'];
            const nouns = ['Panda', 'Eagle', 'Tiger', 'Dragon', 'Phoenix', 'Wolf', 'Fox', 'Bear', 'Hawk', 'Lion'];
            const randomAdj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            const randomNum = Math.floor(Math.random() * 1000);
            return `${randomAdj}${randomNoun}${randomNum}`;
        }

        // Update connection status
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connectionStatus');
            isConnected = connected;
            
            if (connected) {
                statusEl.textContent = '‚úì Connected to Database';
                statusEl.className = 'connection-status connected';
            } else {
                statusEl.textContent = '‚úó Offline Mode';
                statusEl.className = 'connection-status disconnected';
            }
        }

        // Load existing data from Supabase
        async function loadExistingData() {
            const loadingEl = document.getElementById('loadingIndicator');
            loadingEl.style.display = 'block';
            
            try {
                const { data, error } = await supabase
                    .from('responses')
                    .select('*')
                    .order('created_at', { ascending: true });
                
                if (error) {
                    console.error("‚ùå Error loading data:", error);
                    updateConnectionStatus(false);
                    loadingEl.textContent = '‚ö†Ô∏è Could not load data. Working in offline mode.';
                    setTimeout(() => {
                        loadingEl.style.display = 'none';
                    }, 3000);
                    return;
                }
                
                console.log("‚úÖ Loaded", data.length, "existing responses");
                updateConnectionStatus(true);
                
                // Separate by year
                data2025 = data.filter(d => d.year === 2025);
                data2075 = data.filter(d => d.year === 2075);
                
                // Update charts with all data
                const svg2025 = d3.select('#plot2025');
                const svg2075 = d3.select('#plot2075');
                
                if (svg2025.datum()?.vertices) {
                    updateChart('plot2025', data2025, svg2025.datum().vertices);
                }
                if (svg2075.datum()?.vertices) {
                    updateChart('plot2075', data2075, svg2075.datum().vertices);
                }
                
                updateStats();
                loadingEl.style.display = 'none';
            } catch (err) {
                console.error("‚ùå Exception loading data:", err);
                updateConnectionStatus(false);
                loadingEl.textContent = '‚ö†Ô∏è Connection error. Working in offline mode.';
                setTimeout(() => {
                    loadingEl.style.display = 'none';
                }, 3000);
            }
        }

        // Initialize both charts
        function initChart(svgId, year) {
            const svg = d3.select(`#${svgId}`);
            const container = svg.node().parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            svg.attr('width', width).attr('height', height);
            
            const size = Math.min(width, height) - 2 * config.margin;
            const h = size * Math.sqrt(3) / 2;
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Triangle vertices
            const vertices = {
                A: { x: centerX, y: centerY - h * 2/3 },
                B: { x: centerX - size/2, y: centerY + h/3 },
                C: { x: centerX + size/2, y: centerY + h/3 }
            };
            
            // Clear previous content
            svg.selectAll('*').remove();
            
            const g = svg.append('g');
            
            // Draw grid lines
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                
                // Lines parallel to BC
                const p1 = interpolateVertex(vertices.B, vertices.C, 0, t);
                const p2 = interpolateVertex(vertices.B, vertices.C, 1, t);
                g.append('line')
                    .attr('x1', p1.x).attr('y1', p1.y)
                    .attr('x2', p2.x).attr('y2', p2.y)
                    .attr('class', 'grid-line');
                
                // Lines parallel to AC
                const p3 = interpolateVertex(vertices.A, vertices.C, 0, t);
                const p4 = interpolateVertex(vertices.A, vertices.C, 1, t);
                g.append('line')
                    .attr('x1', p3.x).attr('y1', p3.y)
                    .attr('x2', p4.x).attr('y2', p4.y)
                    .attr('class', 'grid-line');
                
                // Lines parallel to AB
                const p5 = interpolateVertex(vertices.A, vertices.B, 0, t);
                const p6 = interpolateVertex(vertices.A, vertices.B, 1, t);
                g.append('line')
                    .attr('x1', p5.x).attr('y1', p5.y)
                    .attr('x2', p6.x).attr('y2', p6.y)
                    .attr('class', 'grid-line');
            }
            
            // Draw triangle border
            g.append('polygon')
                .attr('points', `${vertices.A.x},${vertices.A.y} ${vertices.B.x},${vertices.B.y} ${vertices.C.x},${vertices.C.y}`)
                .attr('fill', 'none')
                .attr('stroke', '#333')
                .attr('stroke-width', 3);
            
            // Add labels
            g.append('text')
                .attr('x', vertices.A.x)
                .attr('y', vertices.A.y - 40)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .text(config.labels.A);
            
            g.append('text')
                .attr('x', vertices.B.x - 50)
                .attr('y', vertices.B.y + 45)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '13px')
                .style('font-weight', 'bold')
                .text('Global Human');
            
            g.append('text')
                .attr('x', vertices.B.x - 50)
                .attr('y', vertices.B.y + 60)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '13px')
                .style('font-weight', 'bold')
                .text('Equality');
            
            g.append('text')
                .attr('x', vertices.C.x + 50)
                .attr('y', vertices.C.y + 45)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '13px')
                .style('font-weight', 'bold')
                .text('Overcoming');
            
            g.append('text')
                .attr('x', vertices.C.x + 50)
                .attr('y', vertices.C.y + 60)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '13px')
                .style('font-weight', 'bold')
                .text('Climate Change');
            
            // Click handler
            svg.on('click', function(event) {
                const hasResponded = year === '2025' ? hasResponded2025 : hasResponded2075;
                
                if (hasResponded) {
                    alert(`You have already submitted your response for ${year}. Each user can only respond once per chart.`);
                    return;
                }
                
                const [mx, my] = d3.pointer(event);
                const barycentric = cartesianToBarycentric(mx, my, vertices);
                
                if (isInsideTriangle(barycentric)) {
                    addDataPoint(year, barycentric, vertices);
                    
                    if (year === '2025') {
                        hasResponded2025 = true;
                    } else {
                        hasResponded2075 = true;
                    }
                    
                    svg.style('cursor', 'not-allowed');
                    svg.style('opacity', '0.7');
                }
            });
            
            svg.datum({ vertices, year });
            
            return { svg, vertices };
        }

        function interpolateVertex(v1, v2, side, t) {
            if (side === 0) {
                return {
                    x: v1.x + t * (v2.x - v1.x),
                    y: v1.y + t * (v2.y - v1.y)
                };
            } else {
                const opposite = side === 1 ? 
                    { x: (v1.x + v2.x) / 2, y: Math.min(v1.y, v2.y) - Math.abs(v2.x - v1.x) * Math.sqrt(3) / 2 } :
                    v1;
                return {
                    x: v1.x + t * (opposite.x - v1.x),
                    y: v1.y + t * (opposite.y - v1.y)
                };
            }
        }

        function cartesianToBarycentric(x, y, vertices) {
            const { A, B, C } = vertices;
            const v0x = C.x - A.x, v0y = C.y - A.y;
            const v1x = B.x - A.x, v1y = B.y - A.y;
            const v2x = x - A.x, v2y = y - A.y;
            
            const dot00 = v0x * v0x + v0y * v0y;
            const dot01 = v0x * v1x + v0y * v1y;
            const dot02 = v0x * v2x + v0y * v2y;
            const dot11 = v1x * v1x + v1y * v1y;
            const dot12 = v1x * v2x + v1y * v2y;
            
            const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
            const c = (dot11 * dot02 - dot01 * dot12) * invDenom;
            const b = (dot00 * dot12 - dot01 * dot02) * invDenom;
            const a = 1 - b - c;
            
            return { a, b, c };
        }

        function barycentricToCartesian(bary, vertices) {
            const { a, b, c } = bary;
            const { A, B, C } = vertices;
            return {
                x: a * A.x + b * B.x + c * C.x,
                y: a * A.y + b * B.y + c * C.y
            };
        }

        function isInsideTriangle(bary) {
            return bary.a >= 0 && bary.b >= 0 && bary.c >= 0 && 
                   Math.abs(bary.a + bary.b + bary.c - 1) < 0.01;
        }

        async function addDataPoint(year, barycentric, vertices) {
            const dataArray = year === '2025' ? data2025 : data2075;
            const svgId = year === '2025' ? 'plot2025' : 'plot2075';
            
            // If offline, store locally
            if (!isConnected) {
                const localResponse = {
                    id: Date.now(),
                    user_id: userNickname,
                    a: barycentric.a,
                    b: barycentric.b,
                    c: barycentric.c,
                    year: parseInt(year),
                    created_at: new Date().toISOString()
                };
                
                dataArray.push(localResponse);
                updateChart(svgId, dataArray, vertices);
                updateStats();
                
                alert(`‚úì Your response for ${year} has been recorded locally!\nYour user ID: ${userNickname}\n\n‚ö†Ô∏è Working offline - data will not be synced to server.`);
                return;
            }
            
            // Save to Supabase
            try {
                const { data: insertedData, error } = await supabase
                    .from('responses')
                    .insert([{
                        user_id: userNickname,
                        a: barycentric.a,
                        b: barycentric.b,
                        c: barycentric.c,
                        year: parseInt(year)
                    }])
                    .select();
                
                if (error) {
                    console.error("‚ùå Supabase insert error:", error);
                    alert("There was an issue saving your response to the database.\n\nError: " + error.message + "\n\nPlease check:\n1. Table 'responses' exists\n2. RLS policies allow INSERT for anon users");
                    return;
                }
                
                console.log("‚úÖ Response saved to Supabase!", insertedData);
                
                if (insertedData && insertedData.length > 0) {
                    dataArray.push(insertedData[0]);
                    updateChart(svgId, dataArray, vertices);
                    updateStats();
                    
                    setTimeout(() => {
                        alert(`‚úì Your response for ${year} has been saved to the database!\n\nYour user ID: ${userNickname}\n\nThe chart is now locked.`);
                    }, 100);
                }
            } catch (err) {
                console.error("‚ùå Exception saving response:", err);
                alert("Network error occurred. Your response could not be saved.\n\n" + err.message);
            }
        }

        function updateChart(svgId, dataArray, vertices) {
            const svg = d3.select(`#${svgId}`);
            
            const points = svg.selectAll('.point').data(dataArray, d => d.id);
            
            points.enter()
                .append('circle')
                .attr('class', 'point')
                .attr('r', 0)
                .attr('fill', svgId === 'plot2025' ? '#667eea' : '#764ba2')
                .attr('opacity', 0.6)
                .attr('stroke', 'white')
                .attr('stroke-width', 2)
                .merge(points)
                .attr('cx', d => {
                    const pos = barycentricToCartesian(d, vertices);
                    return pos.x;
                })
                .attr('cy', d => {
                    const pos = barycentricToCartesian(d, vertices);
                    return pos.y;
                })
                .transition()
                .duration(300)
                .attr('r', 6);
            
            points.exit().remove();
        }

        function updateStats() {
            document.getElementById('count2025').textContent = data2025.length;
            document.getElementById('count2075').textContent = data2075.length;
        }

        function exportData(format = 'json') {
            if (format === 'csv') {
                let csvContent = 'id,user_id,AI Usage,Global Human Equality,Overcoming Climate Change,year,Timestamp\n';
                
                const allData = [...data2025, ...data2075].sort((a, b) => 
                    new Date(a.created_at) - new Date(b.created_at)
                );
                
                allData.forEach(point => {
                    const aiUsage = (point.a * 100).toFixed(2);
                    const equality = (point.b * 100).toFixed(2);
                    const climate = (point.c * 100).toFixed(2);
                    const timestamp = point.created_at || new Date().toISOString();
                    csvContent += `${point.id},${point.user_id},${aiUsage},${equality},${climate},${point.year},${timestamp}\n`;
                });
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `priority_survey_${Date.now()}.csv`;
                link.click();
                URL.revokeObjectURL(url);
            } else {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    data2025: data2025,
                    data2075: data2075,
                    total_responses: data2025.length + data2075.length
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `priority_survey_${Date.now()}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }
        }

        // Initialize charts on load
        window.addEventListener('load', async () => {
            initChart('plot2025', '2025');
            initChart('plot2075', '2075');
            
            await loadExistingData();
            
            if (isConnected) {
                const channel = supabase
                    .channel('responses_changes')
                    .on('postgres_changes', 
                        { event: 'INSERT', schema: 'public', table: 'responses' },
                        (payload) => {
                            console.log('üîî New response received:', payload);
                            
                            if (payload.new.year === 2025) {
                                data2025.push(payload.new);
                                const svg = d3.select('#plot2025');
                                if (svg.datum()?.vertices) {
                                    updateChart('plot2025', data2025, svg.datum().vertices);
                                }
                            } else {
                                data2075.push(payload.new);
                                const svg = d3.select('#plot2075');
                                if (svg.datum()?.vertices) {
                                    updateChart('plot2075', data2075, svg.datum().vertices);
                                }
                            }
                            
                            updateStats();
                        }
                    )
                    .subscribe();
                    
                console.log('‚úÖ Real-time updates enabled');
            }
        });

        window.addEventListener('resize', () => {
            const vertices2025 = initChart('plot2025', '2025').vertices;
            const vertices2075 = initChart('plot2075', '2075').vertices;
            updateChart('plot2025', data2025, vertices2025);
            updateChart('plot2075', data2075, vertices2075);
        });
    </script>
</body>
</html>
