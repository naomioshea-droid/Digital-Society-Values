<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Priority Survey: Present vs Future</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-wrapper {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
            position: relative;
        }
        
        .chart-wrapper::before {
            content: '‚ö†Ô∏è ONE CLICK ONLY';
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff6b6b;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: bold;
            z-index: 10;
        }
        
        .chart-wrapper:hover {
            transform: translateY(-5px);
        }
        
        .chart-title {
            text-align: center;
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .chart-container {
            position: relative;
            width: 100%;
            height: 600px;
        }
        
        .ternary-plot {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .ternary-plot.locked {
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .instructions {
            background: rgba(255,255,255,0.95);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .instructions h2 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .instructions p {
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        .stats {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            text-align: center;
        }
        
        .stats h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .stat-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }
        
        .axis-label {
            font-weight: bold;
            font-size: 14px;
            fill: #333;
            paint-order: stroke;
            stroke: white;
            stroke-width: 3px;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .grid-line {
            stroke: #ddd;
            stroke-width: 1;
        }
        
        .point {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .point:hover {
            r: 8;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #764ba2;
            transform: scale(1.05);
        }
        
        .controls {
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Global Priorities Survey</h1>
            <p class="subtitle">How do your priorities shift from present to future?</p>
        </header>
        
        <div class="instructions">
            <h2>üìä How to Use</h2>
            <p><strong>‚ö†Ô∏è IMPORTANT: You can only click ONCE per chart!</strong> Think carefully before placing your point.</p>
            <p><strong>Click anywhere</strong> inside each triangle to record your priority allocation. Your click represents how you would distribute focus across three critical global challenges.</p>
            <p>The closer your click is to a corner, the more priority you're giving to that challenge. Points near the center represent balanced priorities.</p>
            <p><strong>Challenge yourself:</strong> How do your priorities differ between today and 50 years from now?</p>
        </div>
        
        <div class="charts-container">
            <div class="chart-wrapper">
                <div class="chart-title">Present Day - 2025</div>
                <div class="chart-container">
                    <svg class="ternary-plot" id="plot2025"></svg>
                </div>
            </div>
            
            <div class="chart-wrapper">
                <div class="chart-title">Future - 2075</div>
                <div class="chart-container">
                    <svg class="ternary-plot" id="plot2075"></svg>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <h3>Response Statistics</h3>
            <div class="stat-grid">
                <div class="stat-item">
                    <div class="stat-label">2025 Responses</div>
                    <div class="stat-value" id="count2025">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">2075 Responses</div>
                    <div class="stat-value" id="count2075">0</div>
                </div>
            </div>
            <div class="controls">
                <button onclick="exportData('json')">Export as JSON</button>
                <button onclick="exportData('csv')">Export as CSV</button>
            </div>
        </div>
    </div>

    <script>
        // Data storage
        let data2025 = [];
        let data2075 = [];
        
        // Track if user has responded
        let hasResponded2025 = false;
        let hasResponded2075 = false;
        
        // Generate unique user ID (nickname) for this session
        let userNickname = generateNickname();
        let responseCounter = 0; // Global counter for ID numbers

        // Chart configuration
        const config = {
            width: 500,
            height: 500,
            margin: 100,
            labels: {
                A: 'Maximising AI Usage',
                B: 'Global Human Equality',
                C: 'Overcoming Climate Change'
            }
        };
        
        // Function to generate random nickname
        function generateNickname() {
            const adjectives = ['Swift', 'Bright', 'Bold', 'Wise', 'Cool', 'Quick', 'Smart', 'Clever', 'Sharp', 'Keen'];
            const nouns = ['Panda', 'Eagle', 'Tiger', 'Dragon', 'Phoenix', 'Wolf', 'Fox', 'Bear', 'Hawk', 'Lion'];
            const randomAdj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            const randomNum = Math.floor(Math.random() * 1000);
            return `${randomAdj}${randomNoun}${randomNum}`;
        }

        // Initialize both charts
        function initChart(svgId, year) {
            const svg = d3.select(`#${svgId}`);
            const container = svg.node().parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            svg.attr('width', width).attr('height', height);
            
            const size = Math.min(width, height) - 2 * config.margin;
            const h = size * Math.sqrt(3) / 2;
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Triangle vertices
            const vertices = {
                A: { x: centerX, y: centerY - h * 2/3 },
                B: { x: centerX - size/2, y: centerY + h/3 },
                C: { x: centerX + size/2, y: centerY + h/3 }
            };
            
            // Clear previous content
            svg.selectAll('*').remove();
            
            const g = svg.append('g');
            
            // Draw grid lines
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                
                // Lines parallel to BC
                const p1 = interpolateVertex(vertices.B, vertices.C, 0, t);
                const p2 = interpolateVertex(vertices.B, vertices.C, 1, t);
                g.append('line')
                    .attr('x1', p1.x).attr('y1', p1.y)
                    .attr('x2', p2.x).attr('y2', p2.y)
                    .attr('class', 'grid-line');
                
                // Lines parallel to AC
                const p3 = interpolateVertex(vertices.A, vertices.C, 0, t);
                const p4 = interpolateVertex(vertices.A, vertices.C, 1, t);
                g.append('line')
                    .attr('x1', p3.x).attr('y1', p3.y)
                    .attr('x2', p4.x).attr('y2', p4.y)
                    .attr('class', 'grid-line');
                
                // Lines parallel to AB
                const p5 = interpolateVertex(vertices.A, vertices.B, 0, t);
                const p6 = interpolateVertex(vertices.A, vertices.B, 1, t);
                g.append('line')
                    .attr('x1', p5.x).attr('y1', p5.y)
                    .attr('x2', p6.x).attr('y2', p6.y)
                    .attr('class', 'grid-line');
            }
            
            // Draw triangle border
            g.append('polygon')
                .attr('points', `${vertices.A.x},${vertices.A.y} ${vertices.B.x},${vertices.B.y} ${vertices.C.x},${vertices.C.y}`)
                .attr('fill', 'none')
                .attr('stroke', '#333')
                .attr('stroke-width', 3);
            
            // Add labels with better positioning and visibility
            // Top label - AI Usage
            g.append('text')
                .attr('x', vertices.A.x)
                .attr('y', vertices.A.y - 40)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .text(config.labels.A);
            
            // Bottom left label - Global Human Equality (multi-line, closer to middle)
            g.append('text')
                .attr('x', vertices.B.x - 50)
                .attr('y', vertices.B.y + 45)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '13px')
                .style('font-weight', 'bold')
                .text('Global Human');
            
            g.append('text')
                .attr('x', vertices.B.x - 50)
                .attr('y', vertices.B.y + 60)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '13px')
                .style('font-weight', 'bold')
                .text('Equality');
            
            // Bottom right label - Overcoming Climate Change (multi-line, closer to middle)
            g.append('text')
                .attr('x', vertices.C.x + 50)
                .attr('y', vertices.C.y + 45)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '13px')
                .style('font-weight', 'bold')
                .text('Overcoming');
            
            g.append('text')
                .attr('x', vertices.C.x + 50)
                .attr('y', vertices.C.y + 60)
                .attr('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .style('font-size', '13px')
                .style('font-weight', 'bold')
                .text('Climate Change');
            
            // Click handler
            svg.on('click', function(event) {
                // Check if user has already responded
                const hasResponded = year === '2025' ? hasResponded2025 : hasResponded2075;
                
                if (hasResponded) {
                    alert(`You have already submitted your response for ${year}. Each user can only respond once per chart.`);
                    return;
                }
                
                const [mx, my] = d3.pointer(event);
                const barycentric = cartesianToBarycentric(mx, my, vertices);
                
                if (isInsideTriangle(barycentric)) {
                    addDataPoint(year, barycentric, vertices);
                    
                    // Mark as responded
                    if (year === '2025') {
                        hasResponded2025 = true;
                    } else {
                        hasResponded2075 = true;
                    }
                    
                    // Visual feedback that chart is locked
                    svg.style('cursor', 'not-allowed');
                    svg.style('opacity', '0.7');
                }
            });
            
            // Store vertices for later use
            svg.datum({ vertices, year });
            
            return { svg, vertices };
        }

        function interpolateVertex(v1, v2, side, t) {
            if (side === 0) {
                return {
                    x: v1.x + t * (v2.x - v1.x),
                    y: v1.y + t * (v2.y - v1.y)
                };
            } else {
                const opposite = side === 1 ? 
                    { x: (v1.x + v2.x) / 2, y: Math.min(v1.y, v2.y) - Math.abs(v2.x - v1.x) * Math.sqrt(3) / 2 } :
                    v1;
                return {
                    x: v1.x + t * (opposite.x - v1.x),
                    y: v1.y + t * (opposite.y - v1.y)
                };
            }
        }

        function cartesianToBarycentric(x, y, vertices) {
            const { A, B, C } = vertices;
            const v0x = C.x - A.x, v0y = C.y - A.y;
            const v1x = B.x - A.x, v1y = B.y - A.y;
            const v2x = x - A.x, v2y = y - A.y;
            
            const dot00 = v0x * v0x + v0y * v0y;
            const dot01 = v0x * v1x + v0y * v1y;
            const dot02 = v0x * v2x + v0y * v2y;
            const dot11 = v1x * v1x + v1y * v1y;
            const dot12 = v1x * v2x + v1y * v2y;
            
            const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
            const c = (dot11 * dot02 - dot01 * dot12) * invDenom;
            const b = (dot00 * dot12 - dot01 * dot02) * invDenom;
            const a = 1 - b - c;
            
            return { a, b, c };
        }

        function barycentricToCartesian(bary, vertices) {
            const { a, b, c } = bary;
            const { A, B, C } = vertices;
            return {
                x: a * A.x + b * B.x + c * C.x,
                y: a * A.y + b * B.y + c * C.y
            };
        }

        function isInsideTriangle(bary) {
            return bary.a >= 0 && bary.b >= 0 && bary.c >= 0 && 
                   Math.abs(bary.a + bary.b + bary.c - 1) < 0.01;
        }

        function addDataPoint(year, barycentric, vertices) {
            const dataArray = year === '2025' ? data2025 : data2075;
            const svgId = year === '2025' ? 'plot2025' : 'plot2075';
            
            // Increment response counter
            responseCounter++;
            
            // Add only the user's own response (not displaying other responses)
            const userResponse = {
                id: responseCounter,
                user_id: userNickname,
                a: barycentric.a,
                b: barycentric.b,
                c: barycentric.c,
                year: year,
                timestamp: new Date().toISOString()
            };
            
            dataArray.push(userResponse);
            
            // Display only the user's response
            updateChart(svgId, [userResponse], vertices);
            updateStats();
            
            // Show confirmation message with nickname
            setTimeout(() => {
                alert(`‚úì Your response for ${year} has been recorded!\nYour user ID: ${userNickname}\nThe chart is now locked.`);
            }, 100);
        }

        function updateChart(svgId, dataArray, vertices) {
            const svg = d3.select(`#${svgId}`);
            
            const points = svg.selectAll('.point').data(dataArray);
            
            points.enter()
                .append('circle')
                .attr('class', 'point')
                .attr('r', 0)
                .attr('fill', svgId === 'plot2025' ? '#667eea' : '#764ba2')
                .attr('opacity', 0.6)
                .attr('stroke', 'white')
                .attr('stroke-width', 2)
                .merge(points)
                .attr('cx', d => {
                    const pos = barycentricToCartesian(d, vertices);
                    return pos.x;
                })
                .attr('cy', d => {
                    const pos = barycentricToCartesian(d, vertices);
                    return pos.y;
                })
                .transition()
                .duration(300)
                .attr('r', 6);
            
            points.exit().remove();
        }

        function updateStats() {
            document.getElementById('count2025').textContent = data2025.length;
            document.getElementById('count2075').textContent = data2075.length;
        }

        function exportData(format = 'json') {
            if (format === 'csv') {
                // Create CSV content with specific column order
                let csvContent = 'id,user_id,AI Usage,Global Human Equality,Overcoming Climate Change,year,Timestamp\n';
                
                // Combine both datasets and sort by ID
                const allData = [...data2025, ...data2075].sort((a, b) => a.id - b.id);
                
                // Add each response
                allData.forEach(point => {
                    const aiUsage = (point.a * 100).toFixed(2);
                    const equality = (point.b * 100).toFixed(2);
                    const climate = (point.c * 100).toFixed(2);
                    csvContent += `${point.id},${point.user_id},${aiUsage},${equality},${climate},${point.year},${point.timestamp}\n`;
                });
                
                // Download CSV
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `priority_survey_${Date.now()}.csv`;
                link.click();
                URL.revokeObjectURL(url);
            } else {
                // Original JSON export
                const exportData = {
                    timestamp: new Date().toISOString(),
                    data2025: data2025,
                    data2075: data2075
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `priority_survey_${Date.now()}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }
        }

        // Initialize charts on load
        window.addEventListener('load', () => {
            initChart('plot2025', '2025');
            initChart('plot2075', '2075');
            updateStats();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            const svg2025 = d3.select('#plot2025');
            const svg2075 = d3.select('#plot2075');
            const vertices2025 = initChart('plot2025', '2025').vertices;
            const vertices2075 = initChart('plot2075', '2075').vertices;
            updateChart('plot2025', data2025, vertices2025);
            updateChart('plot2075', data2075, vertices2075);
        });
    </script>
</body>
</html>
